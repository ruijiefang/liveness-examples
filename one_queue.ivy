#lang ivy1.8
include order

instance lclock : unbounded_sequence

module signal0 = {
    action raise

    specification {
        relation now
        after init { now := false; }
        before raise {
            now := true;
            now := false;
        }
        invariant ~now
    }
}

module simple_queue(nat) with nat = {

    var begun(X:nat) : bool 
    var done(X:nat) : bool 
    instance trying : signal0 

    after init {
        begun(X) := false;
        done(X) := false;
    }


    action send(lt:nat) = {
        begun(lt) := true;
    }

    before send(lt:nat) {
        require begun(X) -> X < lt;
    }

    action recv = {
        trying.raise;
        if some x:nat. ~done(x) & begun(x) minimizing x {
                done(x) := true;
        }
    }

    invariant [inv1] begun(X) & done(X) & Y < X & begun(Y) -> done(Y)
    invariant [inv2] done(X) -> begun(X)
    invariant [inv3] ~(X:nat < 0)
} 

instance m : simple_queue(lclock)

export m.send
export m.recv

isolate proofs = {
    explicit temporal property [lemma1]
        (globally eventually m.trying.now) ->
        forall X. (globally m.begun(X) -> eventually m.done(X))
        proof {
            tactic skolemizenp
            tactic l2s_auto5 with {
                definition work_created(X) = m.begun(X)
                definition work_needed(X) = X <= _X & (m.begun(X) & ~m.done(X))
                definition work_invar = m.begun(_X) & ~m.done(_X)
                definition work_progress = m.trying.now
                definition work_helpful = true 
            }
        }

} with this 


#lang ivy1.8
include order

instance lclock : unbounded_sequence

module isolate split_queue2(nat) with nat = {
    action send(lt:nat,kind:bool)

    action recv1
    action recv2

    specification {
        var begun(X:nat) : bool
        var done(X:nat) : bool
        var queue(X:nat) : bool

        after init {
            begun(X) := false;
            done(X) := false;
            trying1 := false;
            trying2 := false;
        }
        var trying1 : bool
        var trying2 : bool

        before send {
            require begun(X) -> X < lt;
            queue(lt) := kind;
            begun(lt) := true;
        }

        before recv1 {
            trying1 := true;
            trying1 := false;
            if some x:nat. ~done(x) & begun(x) minimizing x {
                if queue(x) {
                    done(x) := true;
                }
            }
        }

        before recv2 {
            trying2 := true;
            trying2 := false;
            if some x:nat. ~done(x) & begun(x) minimizing x {
                if ~queue(x) {
                    done(x) := true;
                }
            }
        }

    }

    implementation {
        # prophecy variable telling us the next element to mark as done.
        var firstq : nat 

        after init {
            firstq := 0;
        }
        
        implement send {
            if some y:nat. ~done(y) & begun(y) minimizing y {
                firstq := y;
            }
        }
        implement recv1 {
            if some y:nat. ~done(y) & begun(y) minimizing y {
                firstq := y;
            }
        }
        implement recv2 {
            if some y:nat. ~done(y) & begun(y) minimizing y {
                firstq := y;
            }
        }

        invariant ~trying1 
        invariant ~trying2 

        invariant (begun(firstq) & ~done(firstq)) -> forall X. (X<firstq -> ~begun(X) | done(X))
        invariant forall X. (begun(X) & ~done(X)) -> (begun(firstq) & ~done(firstq)) 
    }


    invariant begun(X) & done(X) & Y < X & begun(Y) -> done(Y)
    invariant done(X) -> begun(X)
    invariant ~(X:nat < 0)
    
    explicit temporal property [lemma1]
    (globally eventually trying1) &
    (globally eventually trying2) ->
    forall X. (globally begun(X) -> eventually done(X))
    proof {
        tactic skolemizenp
        tactic l2s_auto5 with {
            definition work_created[0](X) = begun(X)
            definition work_created[1](X) = begun(X)
            definition work_needed[0](X) = X <= _X & (begun(X) & ~done(X))
            definition work_needed[1](X) = X <= _X & (begun(X) & ~done(X))
            definition work_invar[0] = begun(_X) & ~done(_X)
            definition work_invar[1] = begun(_X) & ~done(_X)
            definition work_progress[0] = trying1
            definition work_progress[1] = trying2 
            definition work_helpful[0] = queue(firstq)
            definition work_helpful[1] = ~queue(firstq) 
        }
    }
} 

instance m : split_queue2(lclock)

export m.send
export m.recv1 
export m.recv2 


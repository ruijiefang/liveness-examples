#lang ivy1.8
include order

instance lclock : unbounded_sequence

module signal0 = {
    action raise

    specification {
        relation now
        after init { now := false; }
        before raise {
            now := true;
            now := false;
        }
        invariant ~now
    }
}

module simple_queue(nat) with nat = {

    var begun1(X:nat) : bool 
    var begun2(X:nat) : bool
    var done2(X:nat) : bool 

    instance trying1 : signal0 
    instance trying2 : signal0 

    after init {
        begun1(X) := false;
        begun2(X) := false;
        done2(X) := false;
    }


    action send1(lt:nat) = {
        begun1(lt) := true;
    }

    before send1(lt:nat) {
        require begun1(X) -> X < lt;
    }

    action recv1 = {
        trying1.raise;
        if some x:nat. ~begun2(x) & begun1(x) minimizing x {
                begun2(x) := true;
        }
    }

    action recv2 = {
        trying2.raise;
        if some x:nat. ~done2(x) & begun2(x) minimizing x {
            done2(x) := true;
        }
    }

    invariant [inv1] begun2(X) & done2(X) & Y < X & begun2(Y) -> done2(Y)
    invariant [inv2] done2(X) -> begun2(X)
    invariant [inv3] begun2(X) -> begun1(X)
    invariant [inv4] begun2(X) & begun1(X) & Y < X & begun2(Y) -> begun1(Y)
    invariant [inv] ~(X:nat < 0)

} 

instance m : simple_queue(lclock)

export m.send1
export m.recv1
export m.recv2

isolate proofs = {
    explicit temporal property [lemma1]
        (globally eventually m.trying1.now) ->
        forall X. (globally m.begun1(X) -> eventually m.begun2(X))
        proof {
            tactic skolemizenp
            tactic l2s_auto5 with {
                definition work_created(X) = m.begun1(X)
                definition work_needed(X) = X <= _X & (m.begun1(X) & ~m.begun2(X))
                definition work_invar = m.begun1(_X) & ~m.begun2(_X)
                definition work_progress = m.trying1.now
                definition work_helpful = m.begun1(_X)
            }
        }

} with this 


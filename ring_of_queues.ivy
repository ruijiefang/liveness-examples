#lang ivy1.8
include order

instance lclock : unbounded_sequence
instance idxseq : unbounded_sequence 

module nq(nat) with nat = {

    var begun(X:nat, I: idxseq) : bool 
    var done(X:nat, I: idxseq) : bool
    var done2(X:nat) : bool 

    relation neighbors(I: idxseq, J: idxseq) # for FAU

    function trying(I: idxseq) : bool 

    var size : idxseq 

    after init {
        require size > 0;
        trying(X) := false;
        begun(X, I) := false;
        done(X, I) := false;
        # linear neighbors relation
        neighbors(I, J) := false;
        neighbors(I, I+1) := true;
    }


    action send(lt:nat) = {
        begun(lt, 0) := true;
    }

    before send(lt:nat) {
        require begun(X, 0) -> X < lt;
    }

    before recv(idx: idxseq) {
        require idx < size;
    }

    action recv(idx: idxseq) = {
        trying(idx) := true;
        trying(idx) := false;
        if some x:nat. begun(x, idx) & ~done(x, idx) minimizing x {
                if (idx + 1 < size) { # has successor
                    done(x, idx) := true;
                    begun(x, idx + 1) := true;
                } else { # no successor
                    assert(idx + 1 = size);
                    done(x, idx) := true;
                }
        }
    }

    invariant [t] ~trying(I)

    invariant [inv1] forall I, J. created_neighbors(I, J) -> (begun(X, J) -> done(X, I))
    invariant [inv2] forall I, J. created_neighbors(I, J) -> (done(X, I) -> begun(X, J)) 

    invariant [inv3] done(X, I) -> begun(X, I)

    function pending(X, I) = begun(X, I) & ~done(X, I)
    function created(I) = I < size 
    function created_neighbors(I, J) = neighbors(I, J) & created(I) & created(J)
} 

instance m : nq(lclock)

export m.send
export m.recv

#isolate proofs = {
#    explicit temporal property [lemma1]
#        ((globally eventually m.trying1) & (globally eventually m.trying2)) ->
#        forall X. (globally m.begun1(X) -> eventually m.done2(X))
#        proof {
#            tactic skolemizenp
#            tactic l2s_auto5 with {
#                definition work_created[1](X) = m.begun1(X) | m.begun2(X)
#                definition work_needed[1](X) = X <= _X & m.begun1(X) & ~m.done1(X)
#                definition work_invar[1] = m.begun1(_X) | m.begun2(_X)
#                definition work_progress[1] = m.trying1
#                definition work_helpful[1] = m.begun1(_X) & ~m.done1(_X)
#
#                definition work_created[2](X) = m.begun1(X) | m.begun2(X)
#                definition work_needed[2](X) = X <= _X & (m.pending1(X) | m.pending2(X))
#                definition work_invar[2] = m.begun1(_X) | m.begun2(_X)
#                definition work_progress[2] = m.trying2
#                definition work_helpful[2] = m.begun2(_X) & ~m.done2(_X)
#
#            }
#        }
#
#} with this 

